# 电磁循迹智能车状态机设计说明

## 概述

本文档描述了为电磁循迹智能车设计的状态机实现方案。该状态机采用函数指针表的方式实现，避免了传统的switch语句，提供了更灵活、可扩展的状态管理机制。

## 状态机架构

### 状态定义

状态机包含以下5个状态：

1. **TRACK_STATE_STOP** - 停止状态
   - 小车停止运动
   - 等待外部命令启动

2. **TRACK_STATE_TRACKING** - 普通循迹状态
   - 使用PID控制进行循迹
   - 监测环岛检测条件

3. **TRACK_STATE_PRE_RING** - 预环岛状态
   - 固定角速度和速度，对准环岛入口
   - 行驶一小段距离后进入环岛

4. **TRACK_STATE_RING** - 环岛中状态
   - 固定角速度和速度，在环岛中行驶
   - 监测出环岛条件

5. **TRACK_STATE_EXIT_RING** - 出环岛状态
   - 固定角速度和速度，使小车回到直道
   - 检测到正常循迹条件后返回普通循迹状态

### 翻车检测功能

状态机集成了基于IMU的翻车检测功能：
- 使用加速度计解算的姿态角（横滚角roll和俯仰角pitch）检测翻车
- 当横滚角或俯仰角超过45度时判定为翻车
- 翻车检测具有最高优先级，会立即触发紧急停止
- 需要持续检测200ms确认翻车，避免误触发

### 状态转换流程

```
STOP → TRACKING → PRE_RING → RING → EXIT_RING → TRACKING
  ↑         ↓                           ↓
  └─────────┴───────────────────────────┘
              ↑
              └─── 翻车检测 (任何状态 → STOP)
```

## 实现特点

### 1. C++状态模式实现

使用面向对象的状态模式替代传统的switch语句：

```cpp
// 状态基类
class State {
public:
    virtual ~State() = default;
    virtual void Enter() {}
    virtual void Exit() {}
    virtual void Update(StateMachine& sm, uint32_t dt) = 0;
    virtual const char* Name() const = 0;
    virtual TrackState ID() const = 0;
};

// 具体状态类
class TrackingState : public State {
public:
    void Update(StateMachine& sm, uint32_t dt) override {
        // 循迹逻辑
    }
    const char* Name() const override { return "TRACKING"; }
    TrackState ID() const override { return TRACK_STATE_TRACKING; }
};

// 状态机上下文
class StateMachine {
    State* m_currentState;
    State* m_states[TRACK_STATE_COUNT];
    // ...
};
```

### 2. 时间管理机制

使用简单的时间计数器实现"持续一定时间"的检测：

```c
static uint32_t state_timer = 0;      // 状态持续时间计数器
static uint32_t condition_timer = 0;  // 条件满足持续时间计数器

// 在TrackHandler中每20ms累加
state_timer += 20;
```

### 3. 外部控制接口

提供简单的命令接口供其他模块控制状态机：

```c
typedef enum {
    TRACK_CMD_START,    // 开始循迹
    TRACK_CMD_STOP,     // 停止
    TRACK_CMD_RESET     // 重置状态机
} TrackCommand;

void TrackSetCommand(TrackCommand cmd);
```

## 配置参数

所有配置参数使用宏定义，便于调整：

```c
#define RING_DETECT_THRESHOLD_MS     500    // 环岛检测时间阈值
#define IN_RING_THRESHOLD_MS         1000   // 环岛中检测时间阈值
#define PRE_RING_VELOCITY           2.0f    // 预环岛固定速度
#define PRE_RING_ANGULAR_VELOCITY   1.0f    // 预环岛固定角速度
#define RING_VELOCITY               1.5f    // 环岛中固定速度
#define RING_ANGULAR_VELOCITY       0.8f    // 环岛中固定角速度
#define EXIT_RING_VELOCITY          2.0f    // 出环岛固定速度
#define EXIT_RING_ANGULAR_VELOCITY  -0.5f   // 出环岛固定角速度
#define TRACKING_VELOCITY           3.0f    // 普通循迹基础速度

// 翻车检测参数
#define ROLL_OVER_ANGLE_THRESHOLD   45.0f   // 翻车检测角度阈值 (度)
#define PITCH_OVER_ANGLE_THRESHOLD  45.0f   // 翻车检测俯仰角阈值 (度)
#define ROLL_OVER_DETECTION_MS      200     // 翻车检测持续时间 (ms)
```

## 使用方法

### 1. 基本控制

```c
// 开始循迹
TrackSetCommand(TRACK_CMD_START);

// 停止小车
TrackSetCommand(TRACK_CMD_STOP);

// 重置状态机
TrackSetCommand(TRACK_CMD_RESET);
```

### 2. 状态查询

```c
TrackState current = TrackGetCurrentState();
const char* state_name = TrackGetStateName(current);
printf("Current state: %s\n", state_name);
```

### 3. 环岛检测函数

需要实现的检测函数（在track.c中）：

```c
static bool IsRingDetected(void);
static bool IsInRingDetected(void);
static bool IsExitRingDetected(void);
```

### 4. 翻车检测功能

状态机已集成翻车检测功能：
- 基于IMU加速度计解算的姿态角检测
- 使用加速度计的三轴数据计算横滚角(roll)和俯仰角(pitch)
- 当横滚角或俯仰角超过45度时判定为翻车
- 需要持续200ms确认翻车，避免误触发
- 翻车检测具有最高优先级，会立即停止小车

姿态角计算公式：
```cpp
// 横滚角 (绕X轴旋转)
float roll = atan2(imu.accel.ay, imu.accel.az) * 180.0f / M_PI;

// 俯仰角 (绕Y轴旋转)
float pitch = atan2(-imu.accel.ax, sqrt(imu.accel.ay * imu.accel.ay + imu.accel.az * imu.accel.az)) * 180.0f / M_PI;
```

## 优势

1. **面向对象设计**：使用C++的状态模式，每个状态是独立的类，逻辑清晰
2. **高度模块化**：状态逻辑完全分离，修改一个状态不影响其他状态
3. **代码简洁**：主循环只需调用`currentState->Update()`，无需冗长的switch语句
4. **易于扩展**：添加新状态只需新增一个类，无需修改现有代码
5. **类型安全**：利用C++的类型系统，减少运行时错误
6. **资源管理**：状态机统一管理PID控制器、计时器等资源
7. **外部控制友好**：提供简单的命令接口，方便其他模块控制
8. **调试友好**：状态名称和日志输出，便于调试和监控

## 扩展建议

1. **添加新状态**：继承State基类，实现新的状态类，在状态机中注册
2. **条件检测优化**：根据实际传感器数据完善环岛检测逻辑
3. **参数调优**：根据实际测试结果调整速度和角速度参数
4. **错误处理**：添加异常状态和错误恢复机制
5. **状态历史记录**：可以添加状态转换历史，便于调试

## 注意事项

1. 状态机由TrackTask每20ms调用一次，时间计算基于此周期
2. 所有环岛目前认定为左环岛，如需支持右环岛需要扩展状态
3. 环岛检测函数需要根据实际传感器数据实现
4. 状态转换是原子操作，确保状态一致性
5. 翻车检测功能依赖于IMU模块，确保IMU正常工作
6. 翻车检测角度阈值为45度，可根据实际测试调整
7. 姿态角计算假设小车静止或低速运动，主要测量重力加速度
8. 在高速运动或颠簸路面可能需要结合陀螺仪数据进行滤波
9. 使用静态实例避免动态内存分配，适合嵌入式环境
10. C++编译器警告"No thread API"是clangd的误报，不影响实际编译